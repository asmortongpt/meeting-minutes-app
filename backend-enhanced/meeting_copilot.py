"""
AI Meeting Copilot - Autonomous Agent
Your intelligent meeting assistant that actually helps!

Features:
- Real-time meeting monitoring
- Automatic action item extraction
- Intelligent suggestions
- Time management
- Follow-up generation
"""
import asyncio
import logging
from typing import Dict, List, Optional, Any
from datetime import datetime, timedelta
from dataclasses import dataclass, field
from enum import Enum

from ai_multi_model import orchestrator, ModelType
from transcription_service import TranscriptSegment

logger = logging.getLogger(__name__)


class CopilotMode(str, Enum):
    """Copilot operating modes"""
    ACTIVE = "active"           # Full real-time assistance
    PASSIVE = "passive"         # Observe only, minimal intervention
    SUMMARY_ONLY = "summary"    # Just generate summary at end
    DISABLED = "disabled"


@dataclass
class MeetingInsight:
    """An insight generated by the copilot"""
    type: str  # action_item, decision, question, blocker, etc.
    content: str
    confidence: float
    timestamp: datetime
    context: Optional[str] = None


@dataclass
class CopilotState:
    """Current state of the copilot"""
    meeting_id: str
    mode: CopilotMode = CopilotMode.ACTIVE
    start_time: datetime = field(default_factory=datetime.utcnow)

    # Tracking
    transcript_segments: List[TranscriptSegment] = field(default_factory=list)
    action_items_detected: List[MeetingInsight] = field(default_factory=list)
    decisions_detected: List[MeetingInsight] = field(default_factory=list)
    questions_raised: List[MeetingInsight] = field(default_factory=list)
    blockers_identified: List[MeetingInsight] = field(default_factory=list)

    # Metrics
    off_topic_count: int = 0
    overtime_warnings: int = 0
    participation_by_speaker: Dict[str, int] = field(default_factory=dict)

    # Agenda tracking
    agenda_items: List[Dict] = field(default_factory=list)
    current_agenda_index: int = 0
    agenda_start_times: Dict[int, datetime] = field(default_factory=dict)


class MeetingCopilot:
    """
    AI Meeting Copilot - Your intelligent meeting assistant

    Capabilities:
    ============

    During Meeting:
    - Auto-transcribe speech in real-time
    - Extract action items as mentioned
    - Track decisions made
    - Detect when going off-topic
    - Monitor time per agenda item
    - Alert when running over
    - Track who speaks and for how long
    - Identify blockers
    - Suggest next steps

    After Meeting:
    - Generate executive summary
    - Create follow-up email drafts
    - Schedule next meeting if needed
    - Update project management tools
    - Send reminders for action items
    """

    def __init__(self):
        self.active_sessions: Dict[str, CopilotState] = {}
        logger.info("ðŸ¤– Meeting Copilot initialized")

    async def start_session(
        self,
        meeting_id: str,
        agenda_items: Optional[List[Dict]] = None,
        mode: CopilotMode = CopilotMode.ACTIVE
    ) -> CopilotState:
        """
        Start a copilot session for a meeting

        Args:
            meeting_id: Unique meeting identifier
            agenda_items: List of agenda items with expected duration
            mode: Operating mode

        Returns:
            CopilotState for tracking
        """

        state = CopilotState(
            meeting_id=meeting_id,
            mode=mode,
            agenda_items=agenda_items or []
        )

        self.active_sessions[meeting_id] = state

        logger.info(f"ðŸŽ¯ Copilot session started for meeting {meeting_id} in {mode} mode")

        return state

    async def process_transcript_segment(
        self,
        meeting_id: str,
        segment: TranscriptSegment
    ) -> List[MeetingInsight]:
        """
        Process a new transcript segment and generate insights

        Args:
            meeting_id: Meeting identifier
            segment: New transcript segment

        Returns:
            List of insights generated from this segment
        """

        if meeting_id not in self.active_sessions:
            logger.warning(f"No active session for meeting {meeting_id}")
            return []

        state = self.active_sessions[meeting_id]

        # Skip if in summary-only mode
        if state.mode == CopilotMode.SUMMARY_ONLY:
            state.transcript_segments.append(segment)
            return []

        # Add to transcript
        state.transcript_segments.append(segment)

        # Track speaker participation
        if segment.speaker_id:
            state.participation_by_speaker[segment.speaker_id] = \
                state.participation_by_speaker.get(segment.speaker_id, 0) + 1

        insights = []

        # Extract action items
        action_items = await self._extract_action_items(segment.text)
        for item in action_items:
            insight = MeetingInsight(
                type="action_item",
                content=item,
                confidence=0.8,
                timestamp=datetime.utcnow(),
                context=segment.text
            )
            state.action_items_detected.append(insight)
            insights.append(insight)

        # Detect decisions
        if await self._is_decision(segment.text):
            insight = MeetingInsight(
                type="decision",
                content=segment.text,
                confidence=0.7,
                timestamp=datetime.utcnow()
            )
            state.decisions_detected.append(insight)
            insights.append(insight)

        # Detect questions
        if "?" in segment.text:
            insight = MeetingInsight(
                type="question",
                content=segment.text,
                confidence=0.9,
                timestamp=datetime.utcnow(),
                context=segment.speaker_id
            )
            state.questions_raised.append(insight)
            insights.append(insight)

        # Detect blockers
        blocker_keywords = ["blocked", "blocker", "can't proceed", "waiting for", "stuck"]
        if any(keyword in segment.text.lower() for keyword in blocker_keywords):
            insight = MeetingInsight(
                type="blocker",
                content=segment.text,
                confidence=0.75,
                timestamp=datetime.utcnow()
            )
            state.blockers_identified.append(insight)
            insights.append(insight)

        # Check if off-topic (in active mode)
        if state.mode == CopilotMode.ACTIVE and state.agenda_items:
            if await self._is_off_topic(segment.text, state):
                insight = MeetingInsight(
                    type="off_topic_warning",
                    content="Discussion may be drifting from agenda",
                    confidence=0.6,
                    timestamp=datetime.utcnow()
                )
                state.off_topic_count += 1
                insights.append(insight)

        return insights

    async def check_time_status(self, meeting_id: str) -> Optional[Dict[str, Any]]:
        """
        Check if meeting is running over time

        Returns:
            Warning dict if over time, None otherwise
        """

        if meeting_id not in self.active_sessions:
            return None

        state = self.active_sessions[meeting_id]

        if not state.agenda_items:
            return None

        current_item = state.agenda_items[state.current_agenda_index] \
            if state.current_agenda_index < len(state.agenda_items) else None

        if not current_item:
            return None

        # Check if started this item
        if state.current_agenda_index not in state.agenda_start_times:
            return None

        start_time = state.agenda_start_times[state.current_agenda_index]
        elapsed = (datetime.utcnow() - start_time).seconds / 60  # minutes
        expected = current_item.get("duration_minutes", 10)

        if elapsed > expected:
            overtime = elapsed - expected
            state.overtime_warnings += 1

            return {
                "type": "time_warning",
                "message": f"Running {overtime:.0f} minutes over on current topic",
                "expected_minutes": expected,
                "actual_minutes": elapsed,
                "agenda_item": current_item.get("title", "Current topic")
            }

        return None

    async def move_to_next_agenda_item(self, meeting_id: str):
        """Move to the next agenda item"""

        if meeting_id not in self.active_sessions:
            return

        state = self.active_sessions[meeting_id]

        state.current_agenda_index += 1
        state.agenda_start_times[state.current_agenda_index] = datetime.utcnow()

        logger.info(f"ðŸ“‹ Moving to agenda item {state.current_agenda_index + 1}")

    async def generate_live_summary(self, meeting_id: str) -> Dict[str, Any]:
        """
        Generate a live summary of the meeting so far

        Returns:
            Summary dict with key points
        """

        if meeting_id not in self.active_sessions:
            return {}

        state = self.active_sessions[meeting_id]

        # Combine recent transcript
        recent_text = " ".join([
            seg.text for seg in state.transcript_segments[-20:]  # Last 20 segments
        ])

        prompt = f"""Provide a brief status update for this ongoing meeting:

Recent discussion:
{recent_text}

Provide:
1. What's been discussed so far (2-3 sentences)
2. Key points made
3. Any decisions or action items mentioned
4. Current focus/topic

Keep it concise - this is a live update."""

        result = await orchestrator.generate(
            prompt,
            model_type=ModelType.SUMMARY,
            prefer_speed=True
        )

        return {
            "summary": result["response"],
            "action_items_count": len(state.action_items_detected),
            "decisions_count": len(state.decisions_detected),
            "questions_count": len(state.questions_raised),
            "duration_minutes": (datetime.utcnow() - state.start_time).seconds // 60,
            "speakers": len(state.participation_by_speaker)
        }

    async def end_session(self, meeting_id: str) -> Dict[str, Any]:
        """
        End copilot session and generate final summary

        Returns:
            Complete meeting summary and insights
        """

        if meeting_id not in self.active_sessions:
            return {}

        state = self.active_sessions[meeting_id]

        logger.info(f"ðŸ Ending copilot session for meeting {meeting_id}")

        # Generate comprehensive summary
        full_transcript = " ".join([seg.text for seg in state.transcript_segments])

        prompt = f"""Analyze this complete meeting transcript and provide:

1. **Executive Summary** (3 bullet points max - the absolute key takeaways)
2. **Decisions Made** (list each decision with rationale)
3. **Action Items** (task, owner if mentioned, priority)
4. **Key Discussion Points** (main topics covered)
5. **Blockers/Risks** (anything mentioned that could delay progress)
6. **Next Steps** (recommended follow-up actions)
7. **Overall Sentiment** (was the meeting productive? team morale?)

Meeting Transcript:
{full_transcript}

Return as structured JSON."""

        result = await orchestrator.generate(
            prompt,
            model_type=ModelType.ANALYSIS,
            prefer_quality=True
        )

        # Calculate participation metrics
        total_turns = sum(state.participation_by_speaker.values())
        participation_percentages = {
            speaker: (turns / total_turns * 100) if total_turns > 0 else 0
            for speaker, turns in state.participation_by_speaker.items()
        }

        # Meeting duration
        duration = datetime.utcnow() - state.start_time

        summary = {
            "meeting_id": meeting_id,
            "duration_minutes": duration.seconds // 60,
            "ai_summary": result["response"],

            # Metrics
            "total_speakers": len(state.participation_by_speaker),
            "total_words": sum(len(seg.text.split()) for seg in state.transcript_segments),
            "action_items_detected": len(state.action_items_detected),
            "decisions_made": len(state.decisions_detected),
            "questions_raised": len(state.questions_raised),
            "blockers_identified": len(state.blockers_identified),
            "off_topic_incidents": state.off_topic_count,
            "overtime_warnings": state.overtime_warnings,

            # Participation
            "speaker_participation": participation_percentages,

            # Quality scores
            "meeting_quality_score": await self._calculate_quality_score(state),
            "productivity_rating": await self._calculate_productivity_rating(state),

            # Model used
            "ai_model": result.get("model_used"),
            "processing_cost": result.get("cost")
        }

        # Cleanup
        del self.active_sessions[meeting_id]

        return summary

    async def generate_follow_up_email(
        self,
        meeting_summary: Dict[str, Any],
        attendees: List[str]
    ) -> str:
        """
        Generate a follow-up email draft

        Args:
            meeting_summary: Summary from end_session()
            attendees: List of attendee names/emails

        Returns:
            Email draft as string
        """

        attendee_list = ", ".join(attendees)

        prompt = f"""Write a professional follow-up email for this meeting.

Meeting Summary:
{meeting_summary.get('ai_summary', 'N/A')}

Attendees: {attendee_list}

The email should:
- Thank attendees for their time
- Summarize key decisions
- List action items clearly
- Mention any blockers that need attention
- Suggest next steps
- Be warm but professional

Return just the email body (no subject line)."""

        result = await orchestrator.generate(
            prompt,
            model_type=ModelType.SUMMARY,
            prefer_quality=True
        )

        return result["response"]

    # ========================================================================
    # HELPER METHODS
    # ========================================================================

    async def _extract_action_items(self, text: str) -> List[str]:
        """Extract potential action items from text"""

        # Quick keyword check
        action_keywords = [
            "will", "should", "need to", "have to", "must",
            "todo", "to do", "action item", "follow up",
            "assign", "responsible for"
        ]

        if not any(keyword in text.lower() for keyword in action_keywords):
            return []

        # Use AI for more accurate extraction
        prompt = f"""Extract action items from this text. Return only the action item descriptions, one per line.

Text: {text}

If no action items, return empty."""

        result = await orchestrator.generate(
            prompt,
            model_type=ModelType.SUMMARY,
            prefer_speed=True,
            max_cost=0.005
        )

        items = [
            line.strip() for line in result["response"].split("\n")
            if line.strip() and not line.strip().lower().startswith("no ")
        ]

        return items[:3]  # Max 3 per segment

    async def _is_decision(self, text: str) -> bool:
        """Check if text contains a decision"""

        decision_keywords = [
            "decided", "decision", "agreed", "going with",
            "chosen", "selected", "approved", "confirmed"
        ]

        return any(keyword in text.lower() for keyword in decision_keywords)

    async def _is_off_topic(self, text: str, state: CopilotState) -> bool:
        """Check if discussion is off the current agenda topic"""

        if state.current_agenda_index >= len(state.agenda_items):
            return False

        current_topic = state.agenda_items[state.current_agenda_index].get("title", "")

        if not current_topic:
            return False

        # Simple relevance check (could be enhanced with embeddings)
        topic_keywords = current_topic.lower().split()
        text_lower = text.lower()

        # If topic keywords appear in text, likely on topic
        matches = sum(1 for keyword in topic_keywords if keyword in text_lower)

        return matches == 0 and len(text.split()) > 10

    async def _calculate_quality_score(self, state: CopilotState) -> int:
        """
        Calculate meeting quality score (0-100)

        Factors:
        - Agenda followed
        - Time management
        - Participation balance
        - Decisions made
        - Action items created
        """

        score = 50  # Start at 50

        # Good agenda following
        if state.agenda_items and state.off_topic_count < 3:
            score += 10

        # Good time management
        if state.overtime_warnings < 2:
            score += 10

        # Balanced participation
        if state.participation_by_speaker:
            participation_values = list(state.participation_by_speaker.values())
            if len(participation_values) > 1:
                # Check if participation is relatively balanced
                max_val = max(participation_values)
                min_val = min(participation_values)
                if max_val / (min_val + 1) < 3:  # No one dominates
                    score += 10

        # Productive (decisions made)
        score += min(len(state.decisions_detected) * 5, 10)

        # Actionable (action items created)
        score += min(len(state.action_items_detected) * 3, 10)

        return min(score, 100)

    async def _calculate_productivity_rating(self, state: CopilotState) -> str:
        """Calculate productivity rating"""

        score = await self._calculate_quality_score(state)

        if score >= 80:
            return "Excellent"
        elif score >= 60:
            return "Good"
        elif score >= 40:
            return "Fair"
        else:
            return "Needs Improvement"


# Global copilot instance
copilot = MeetingCopilot()
